// state.c generated by gen_state from state.json and state.skel.c
// manual edits to state.skel.c will be reflected in state.c
// manual edits to state.c will be discarded

#include <stdint.h>

// Macros for code produced by gen_state
#define if_config(X)            (p->flags & (X))
#define accept_null(X)          ((X), JSONPG_NULL)
#define accept_true(X)          ((X), JSONPG_TRUE)
#define accept_false(X)         ((X), JSONPG_FALSE)
#define push_token(X)           push_token(p, (X))
#define pop_token()             pop_token(p)
#define ifpeek_token(X)         ((X) == p->tokens[p->token_ptr - 1].type)
#define swap_token(X)           (p->tokens[p->token_ptr - 1].type = (X))
#define push_state(X)           (p->push_state = (X))
#define pop_state()             (p->push_state)
#define begin_object()          begin_object(p)
#define end_object()            end_object(p)
#define begin_array()           begin_array(p)
#define end_array()             end_array(p)
#define in_object()             (peek_stack(&p->stack) == STACK_OBJECT)
#define in_array()              (peek_stack(&p->stack) == STACK_ARRAY)
#define accept_integer(X)       accept_integer(p, (X))
#define accept_real(X)          accept_real(p, (X))
#define accept_string(X)        accept_string(p, (X))
#define accept_key(X)           accept_key(p, (X))
#define accept_sq_string(X)     accept_string(X)
#define accept_sq_key(X)        accept_key(X)
#define accept_nq_string(X)     accept_string(X)
#define accept_nq_key(X)        accept_key(X)
#define process_escape(X)       process_escape(p, (X))
#define process_escape_chars(X) process_escape_chars(p, (X))
#define process_escape_u(X)     process_escape_u(p, (X))

typedef enum {
        config_comments = JSONPG_FLAG_COMMENTS,
        config_trailing_commas = JSONPG_FLAG_TRAILING_COMMAS,
        config_single_quotes = JSONPG_FLAG_SINGLE_QUOTES,
        config_unquoted_keys = JSONPG_FLAG_UNQUOTED_KEYS,
        config_unquoted_strings = JSONPG_FLAG_UNQUOTED_STRINGS,
        config_escape_characters = JSONPG_FLAG_ESCAPE_CHARACTERS,
        config_optional_commas = JSONPG_FLAG_OPTIONAL_COMMAS
} config_flags;

uint8_t state_map[][256] = {
<= map

};

typedef enum {
<= enums
,
        state_initial = STATE_INITIAL,
        state_error   = STATE_ERROR
} state;

#ifdef JSONPG_DEBUG
char *states[256] = {
<= enum_names
,
        [state_initial] = "state_initial",
        [state_error] = "state_error",
<= cases

};
#endif

jsonpg_type parse_next(jsonpg_parser p) {
        static void* dispatch_table[0x80] = {
<= gotos

                [0x7F] = &&Lerror      
        };

        if(p->state == state_initial) {
                p->push_state = 
                        (p->flags & JSONPG_FLAG_IS_OBJECT)
                                ? state_w_key
                                : state_w_value;
                p->state = state_whitespace;
        }
        str_buf_reset(p->write_buf);
        jsonpg_type result = JSONPG_NONE;
        state new_state;

        while(1) {
                const uint8_t *last = p->last;
                while(p->current < last) {
                        state current_state = state_map[p->state][*p->current];

                        JSONPG_LOG("State change: %s [%02X:%c] => %s\n", 
                                        states[p->state],
                                        *p->current,
                                        log_printablechar(*p->current),
                                        states[current_state]);

                        state jump_state = current_state & 0x7F;

                        //if(!(current_state & 0x80)) {
                        if(current_state == jump_state) {
                                p->state = current_state;
                                p->current++;
                                continue;
                        }
                        
                        //state new_state = state_error;
                        //int incr = 1;
                        //switch((int)current_state) {
                        goto *dispatch_table[jump_state];
<= code

                        Linc:
                                p->current++;
                        Lnoinc:
                                if(new_state == state_error)
                                        goto Lerror;

                                p->state = new_state;
                                
                        //
                        // if(new_state == state_error)
                        //         return parse_error(p);
                        //
                        // JSONPG_LOG("New state: %s, use %s input\n",
                        //                 states[new_state],
                        //                 incr ? "next" : "same");
                        //
                        // p->state = new_state;
                        // p->current += incr;
                        //
                        // if(result == JSONPG_NONE) {
                        //         return result;
                        // }

                                if(result == JSONPG_NONE)
                                        continue;
                                
                                return result;

                        Lerror:
                                return parse_error(p);
                }
                if(p->seen_eof) {

                        JSONPG_LOG("Exiting... state=%s, push_state=%s token_ptr=%d, stack_ptr=%d\n",
                                        states[p->state],
                                        states[p->push_state],
                                        p->token_ptr,
                                        p->stack.ptr);

                        // no whitespace after number leaves it dangling
                        if(p->state == state_zero_integer
                                        || p->state == state_integer) {
                                p->push_state = state_error;
                                p->state = state_whitespace;
                                return accept_integer(pop_token());
                        } else if(p->state == state_fraction
                                        || p->state == state_exponent) {
                                p->push_state = state_error;
                                p->state = state_whitespace;
                                return accept_real(pop_token());
                        }

                        return (p->push_state == state_error
                                        && p->token_ptr == 0 
                                        && p->stack.ptr == p->stack.ptr_min)
                               ? JSONPG_EOF
                               : parse_error(p);
                } else if(-1 == parser_read_next(p)) {
                        return file_read_error(p);
                }
        }
}
